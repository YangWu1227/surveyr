% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/list_xtab_args.R
\name{list_xtab_3way_args}
\alias{list_xtab_3way_args}
\title{Generate multiple lists of three-way crosstab arguments}
\usage{
list_xtab_3way_args(df, control_var, independent_vars, dependent_vars)
}
\arguments{
\item{df}{A data frame or tibble.}

\item{control_var}{A character vector of control variables.}

\item{independent_vars}{A list of character vectors, each of which contains independent variables.}

\item{dependent_vars}{A list of character vectors, each of which contains dependent variables.}
}
\value{
A list containing two elements--- \code{result} and \code{error}, which are lists in and of themselves.
These two lists have the same structure and number of elements. The \code{result} is a \strong{named} list
of \code{tibble} objects. One can think of each \code{tibble} as the output of a single run of \code{generate_xtab_3way_args()},
\emph{if it suceeds.} The \code{error} list captures all runs of \code{generate_xtab_3way_args()} that have failed,
returning the error messages. If all run fails, \code{result} will be a \code{NULL} list; on the other end, if no run
fails, \code{error} will be a \code{NULL} list. Users can easily find out which \code{control_var} failed by examining
the \code{error} list and running the following code (assuming that the list is called \code{list_of_args_3way} and the
vector of control variables is called \code{control_var}):
\preformatted{
        lgl_index <- purrr::map_lgl(list_of_args_3way[["error"]], is.null)
        control_var[!lgl_index]
  }
To examine the results of the successful runs, use:
\preformatted{
        list_of_args_3way[["result"]][lgl_index]
  }
Or, if all runs are successful, simply return the \code{result} list:
\preformatted{
        list_of_xtab_3way_args <- list_of_args_3way[["result"]]
  }
}
\description{
Simply put, \code{list_xtab_3way_args()} is a vectorized version of \code{generate_xtab_3way_args()}. The function
\code{generate_xtab_3way_args()} allows for one \code{control_var} at a time. There may be use cases where
multiple \code{control_var} must be considered. In those cases, this function may be useful as it
allows users to pass a vector of \code{control_var} and corresponding lists of \code{independent_vars} and
\code{dependent_vars}. These three vectors must be of the same length in terms of \code{vec_size()}. One may think of
these three vectors as trios in the sence that--- each ith element in \code{control_var} is crossed with each
elements of \code{independent_vars} and \code{dependent_vars}, which are vectors in and of themselves.
}
\examples{
\donttest{
# Create control_var vector
control_var <- c("col1", "col3", "col20", "col23")

# List of independent variable vectors
independent_vars <- list(
  c("col9", "col2", "col5", "col100"),
  c("col2", "col4"),
  c("col7", "col9", "col40", "col17"),
  c("col2", "col11")
)

# List of dependent variable vectors
dependent_vars <- list(
  c("col2", "col4", "col5", "col100"),
  c("col2", "col4"),
  c("col2", "col4", "col5", "col86"),
  c("col2", "col4")
)

# Create list_of_args_3way
list_of_args_3way <- list_xtab_3way_args(df, control_var, independent_vars, dependent_vars)
}
}
